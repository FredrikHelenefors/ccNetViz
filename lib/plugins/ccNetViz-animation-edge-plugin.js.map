{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./shaders/easeFunctions/index.js","webpack:///./shaders/easeFunctions/linear.glsl","webpack:///./shaders/easeFunctions/sin-in.glsl","webpack:///./shaders/easeFunctions/sin-out.glsl","webpack:///./shaders/easeFunctions/sin-inout.glsl","webpack:///./shaders/easeFunctions/sin-inout-inv.glsl","webpack:///./shaders/easeFunctions/exp-in.glsl","webpack:///./shaders/easeFunctions/exp-out.glsl","webpack:///./shaders/easeFunctions/exp-inout.glsl","webpack:///./shaders/easeFunctions/bounce-in.glsl","webpack:///./shaders/easeFunctions/bounce-out.glsl","webpack:///./shaders/easeFunctions/bounce-inout.glsl","webpack:///./shaders/easeFunctions/circular-in.glsl","webpack:///./shaders/easeFunctions/circular-out.glsl","webpack:///./shaders/easeFunctions/circular-inout.glsl","webpack:///./shaders/easeFunctions/quad-in.glsl","webpack:///./shaders/easeFunctions/quad-out.glsl","webpack:///./shaders/easeFunctions/quad-inout.glsl","webpack:///./shaders/easeFunctions/cubic-in.glsl","webpack:///./shaders/easeFunctions/cubic-out.glsl","webpack:///./shaders/easeFunctions/cubic-inout.glsl","webpack:///./shaders/easeFunctions/quart-in.glsl","webpack:///./shaders/easeFunctions/quart-out.glsl","webpack:///./shaders/easeFunctions/quart-inout.glsl","webpack:///./shaders/easeFunctions/quart-inout-inv.glsl","webpack:///./shaders/easeFunctions/quint-in.glsl","webpack:///./shaders/easeFunctions/quint-out.glsl","webpack:///./shaders/easeFunctions/quint-inout.glsl","webpack:///./shaders/elements/vsLineHead.glsl","webpack:///./shaders/elements/fsLineHead.glsl","webpack:///./shaders/elements/fsLineAnimateFuncs.glsl","webpack:///./shaders/elements/fsLineMain.glsl","webpack:///./shaders/elements/index.js","webpack:///./shaders/elements/getShiftFuncs.glsl","webpack:///./shaders/elements/vsLineMain.glsl","webpack:///./shapes/animateLine.js","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","easeFunctions","linear","vsLine","join","easeFunctionPart","ease","elementShaders","fsLineAnimate","fsLineHead","fsLineAnimateFuncs","fsLineMain","BaseShape","ccNetViz","ccNetViz_primitive","tools","primitive","ccNetViz_gl","gl","ccNetViz_geomutils","geomutils","normalize","stylesTransl","line","dashed","dotted","getEdgeType","undefined","getEdgeStyleSize","width","animateStylesTransl","none","basic","gradient","getEdgeAnimateType","AnimateLine","constructor","edgeStyle","super","this","filler","shapeFillers","lines","hasAnimation","animateType","hasShapeAnimation","_primitive","animateEase","uniforms","shader","exc","uniform1f","curveExc","uniform2f","screen","height","size","nodeSize","lineSize","aspect2","aspect","style","type","uniformColor","color","animateSpeed","animateColor","animateMaxWidth","uniform1i","animateDotNum","animateDotInterval","set","v","e","iV","iI","edgeSource","edgeTarget","dx","x","dy","y","csx","csy","ctx","cty","cisx","cisy","citx","city","ct1","ct2","getCurveShift","cx","cy","curveShift","vertices","circleShift","setVerticeCurveShift","position","lengthSoFar","normal","startPos","endPos","quad","indices","console","error","BasePlugin","Shaders","edge","options","scene","add","runRegistrations","textures","register","section","addSection","texture"],"mappings":"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","file":"ccNetViz-animation-edge-plugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import linear from './linear.glsl';\r\nimport sinIn from './sin-in.glsl';\r\nimport sinOut from './sin-out.glsl';\r\nimport sinInOut from './sin-inout.glsl';\r\nimport sinInOutInv from './sin-inout-inv.glsl';\r\nimport expIn from './exp-in.glsl';\r\nimport expOut from './exp-out.glsl';\r\nimport expInOut from './exp-inout.glsl';\r\nimport bounceIn from './bounce-in.glsl';\r\nimport bounceOut from './bounce-out.glsl';\r\nimport bounceInOut from './bounce-inout.glsl';\r\nimport circularIn from './circular-in.glsl';\r\nimport circularOut from './circular-out.glsl';\r\nimport circularInOut from './circular-inout.glsl';\r\nimport quadIn from './quad-in.glsl';\r\nimport quadOut from './quad-out.glsl';\r\nimport quadInOut from './quad-inout.glsl';\r\nimport cubicIn from './cubic-in.glsl';\r\nimport cubicOut from './cubic-out.glsl';\r\nimport cubicInOut from './cubic-inout.glsl';\r\nimport quartIn from './quart-in.glsl';\r\nimport quartOut from './quart-out.glsl';\r\nimport quartInOut from './quart-inout.glsl';\r\nimport quartInOutInv from './quart-inout-inv.glsl';\r\nimport quintIn from './quint-in.glsl';\r\nimport quintOut from './quint-out.glsl';\r\nimport quintInOut from './quint-inout.glsl';\r\n\r\nconst easeFunctions = {\r\n  linear: linear,\r\n  'sin-in': sinIn,\r\n  'sin-out': sinOut,\r\n  'sin-inout': sinInOut,\r\n  'sin-inout-inv': sinInOutInv,\r\n  'exp-in': expIn,\r\n  'exp-out': expOut,\r\n  'exp-inout': expInOut,\r\n  'bounce-in': bounceIn,\r\n  'bounce-out': bounceOut,\r\n  'bounce-inout': bounceInOut,\r\n  'circular-in': circularIn,\r\n  'circular-out': circularOut,\r\n  'circular-inout': circularInOut,\r\n  'quad-in': quadIn,\r\n  'quad-out': quadOut,\r\n  'quad-inout': quadInOut,\r\n  'cubic-in': cubicIn,\r\n  'cubic-out': cubicOut,\r\n  'cubic-inout': cubicInOut,\r\n  'quart-in': quartIn,\r\n  'quart-out': quartOut,\r\n  'quart-inout': quartInOut,\r\n  'quart-inout-inv': quartInOutInv,\r\n  'quint-in': quintIn,\r\n  'quint-out': quintOut,\r\n  'quint-inout': quintInOut,\r\n};\r\n\r\nexport { easeFunctions };\r\n","export default \"float ease(float t) {\\r\\n  return t;\\r\\n}\\r\\n\"","export default \"#ifndef HALF_PI\\r\\n#define HALF_PI 1.5707963267948966\\r\\n#endif\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return sin((t - 1.0) * HALF_PI) + 1.0;\\r\\n}\\r\\n\"","export default \"#ifndef HALF_PI\\r\\n#define HALF_PI 1.5707963267948966\\r\\n#endif\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return sin(t * HALF_PI);\\r\\n}\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return -0.5 * (cos(PI * t) - 1.0);\\r\\n}\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return acos(1. - 2. * t) / PI;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\\r\\n}\\r\\n\"","export default \"float ease(float t) {\\r\\n  return t == 0.0 || t == 1.0\\r\\n    ? t\\r\\n    : t < 0.5\\r\\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\\r\\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\\r\\n}\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat bounceOut(float t) {\\r\\n  const float a = 4.0 / 11.0;\\r\\n  const float b = 8.0 / 11.0;\\r\\n  const float c = 9.0 / 10.0;\\r\\n\\r\\n  const float ca = 4356.0 / 361.0;\\r\\n  const float cb = 35442.0 / 1805.0;\\r\\n  const float cc = 16061.0 / 1805.0;\\r\\n\\r\\n  float t2 = t * t;\\r\\n\\r\\n  return t < a\\r\\n    ? 7.5625 * t2\\r\\n    : t < b\\r\\n      ? 9.075 * t2 - 9.9 * t + 3.4\\r\\n      : t < c\\r\\n        ? ca * t2 - cb * t + cc\\r\\n        : 10.8 * t * t - 20.52 * t + 10.72;\\r\\n}\\r\\n\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return 1.0 - bounceOut(1.0 - t);\\r\\n}\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat ease(float t) {\\r\\n  const float a = 4.0 / 11.0;\\r\\n  const float b = 8.0 / 11.0;\\r\\n  const float c = 9.0 / 10.0;\\r\\n\\r\\n  const float ca = 4356.0 / 361.0;\\r\\n  const float cb = 35442.0 / 1805.0;\\r\\n  const float cc = 16061.0 / 1805.0;\\r\\n\\r\\n  float t2 = t * t;\\r\\n\\r\\n  return t < a\\r\\n    ? 7.5625 * t2\\r\\n    : t < b\\r\\n      ? 9.075 * t2 - 9.9 * t + 3.4\\r\\n      : t < c\\r\\n        ? ca * t2 - cb * t + cc\\r\\n        : 10.8 * t * t - 20.52 * t + 10.72;\\r\\n}\\r\\n\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat bounceOut(float t) {\\r\\n  const float a = 4.0 / 11.0;\\r\\n  const float b = 8.0 / 11.0;\\r\\n  const float c = 9.0 / 10.0;\\r\\n\\r\\n  const float ca = 4356.0 / 361.0;\\r\\n  const float cb = 35442.0 / 1805.0;\\r\\n  const float cc = 16061.0 / 1805.0;\\r\\n\\r\\n  float t2 = t * t;\\r\\n\\r\\n  return t < a\\r\\n    ? 7.5625 * t2\\r\\n    : t < b\\r\\n      ? 9.075 * t2 - 9.9 * t + 3.4\\r\\n      : t < c\\r\\n        ? ca * t2 - cb * t + cc\\r\\n        : 10.8 * t * t - 20.52 * t + 10.72;\\r\\n}\\r\\n\\r\\nfloat ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\\r\\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return 1.0 - sqrt(1.0 - t * t);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return sqrt((2.0 - t) * t);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\\r\\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t * t;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return -t * (t - 2.0);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? +8.0 * pow(t, 4.0)\\r\\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t * t * t;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  float f = t - 1.0;\\r\\n  return f * f * f + 1.0;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? 4.0 * t * t * t\\r\\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return pow(t, 4.0);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? +8.0 * pow(t, 4.0)\\r\\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? pow((t / 8.), 0.25)\\r\\n    : -pow((1.0 - t) / 8., 0.25) + 1.;\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return pow(t, 5.0);\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return 1.0 + (pow(t - 1.0, 5.0)); // NOTE: fix original bug '-' -> '+'\\r\\n}\"","export default \"float ease(float t) {\\r\\n  return t < 0.5\\r\\n    ? +16.0 * pow(t, 5.0)\\r\\n    : 0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0; // NOTE: fix original bug, no '-'\\r\\n}\\r\\n\"","export default \"precision mediump float;\\r\\nattribute vec2 position;\\r\\nattribute vec2 normal;\\r\\nattribute vec2 lengthSoFar;\\r\\nattribute vec2 startPos;\\r\\nattribute vec2 endPos;\\r\\nuniform float time;\\r\\nuniform float exc;\\r\\nuniform vec2 size;\\r\\nuniform vec2 screen;\\r\\nuniform float aspect2;\\r\\nuniform float aspect;\\r\\nuniform float width;\\r\\nuniform float animateMaxWidth;\\r\\nuniform mat4 transform;\\r\\nvarying float v_time;\\r\\nvarying vec2 v_startPos;\\r\\nvarying vec2 v_endPos;\\r\\nvarying vec2 v_screen;\\r\\nvarying vec2 n;\\r\\nvarying vec2 v_lengthSoFar;\\r\\nvarying float v_lineWidth;\\r\\nvarying float v_animateMaxWidth;\\r\\nvarying vec2 v_size;\\r\\n\"","export default \"precision mediump float;\\r\\nuniform float type;\\r\\nuniform float animateType;\\r\\nuniform vec4 color;\\r\\nuniform vec4 animateColor;\\r\\nuniform float animateSpeed;\\r\\nuniform int animateDotNum;\\r\\nuniform float animateDotInterval;\\r\\nvarying vec2 n;\\r\\nvarying float v_time;\\r\\nvarying vec2 v_startPos;\\r\\nvarying vec2 v_endPos;\\r\\nvarying vec2 v_screen;\\r\\nvarying vec2 v_lengthSoFar;\\r\\nvarying float v_lineWidth;\\r\\nvarying float v_animateMaxWidth;\\r\\nvarying vec2 v_size;\\r\\n\\r\\nuniform float lineSize;\\r\\n\"","export default \"#ifndef PI\\r\\n#define PI 3.141592653589793\\r\\n#endif\\r\\n\\r\\nfloat isAnimateCovered() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  float len = distance(pos, startPos);\\r\\n  // float r = 300.;\\r\\n  float r =\\r\\n      ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n  // float r = 0.5 * totalLen;\\r\\n  float draw = 1. - step(r, len);\\r\\n  return draw;\\r\\n}\\r\\n\\r\\nfloat isAnimateCoveredGradient() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  float len = distance(pos, startPos);\\r\\n  float gradLen = 180.; // TODO: can config\\r\\n  float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) *\\r\\n            (totalLen + gradLen / 2.); // NOTE: use 0.2 as a proper factor\\r\\n  // float r = 0.5 * totalLen;\\r\\n  float draw = fract(smoothstep(r - gradLen, r, len));\\r\\n  return draw;\\r\\n}\\r\\n\\r\\nfloat isAnimateCoveredDoubleGradient() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  float len = distance(pos, startPos);\\r\\n  float gradLen = 90.; // TODO: can config\\r\\n  float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) *\\r\\n            (totalLen + gradLen / 2.); // NOTE: use 0.2 as a proper factor\\r\\n\\r\\n  float draw = (1. - step(r, len)) * fract(smoothstep(r - gradLen, r, len)) +\\r\\n               (1. - step(r + gradLen, len)) * step(r, len) *\\r\\n                   (1. - fract(smoothstep(r, r + gradLen, len)));\\r\\n  return draw;\\r\\n}\\r\\n\\r\\nfloat isAnimateBubble() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  vec2 vec = endPos - startPos;\\r\\n  vec2 norm = normalize(vec2(-vec.y, vec.x));\\r\\n  // vec2 norm = normalize(n);\\r\\n  mat2 rotateMat = mat2(norm.y, norm.x, -norm.x, norm.y); // rotate to horizental\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  float r = v_animateMaxWidth * 2. + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 4.);\\r\\n  // float r = 0.5 * totalLen;\\r\\n\\r\\n  float currWidth = length(dot(pos - startPos, norm));\\r\\n\\r\\n  vec2 center = startPos + normalize(vec) * r;\\r\\n  vec2 newPos = center + (rotateMat * (pos - center));\\r\\n  vec2 relativePos = newPos - center;\\r\\n\\r\\n  // if (currWidth > v_lineWidth && length(pos - center) > v_animateMaxWidth) {\\r\\n    // return 0.;\\r\\n  // }\\r\\n\\r\\n  float shapeLen = 4. * v_animateMaxWidth; // TODO: may be configurable\\r\\n  float A = (v_animateMaxWidth - v_lineWidth) / 2.;\\r\\n  float K = 2. * PI / shapeLen;\\r\\n  float B = v_lineWidth + (v_animateMaxWidth - v_lineWidth) / 2.;\\r\\n  float draw = 1.;\\r\\n  if (currWidth > v_lineWidth) {\\r\\n    draw = 0.;\\r\\n  }\\r\\n  if (length(relativePos.x) < shapeLen / 2. && abs(A * cos(K * relativePos.x) + B) > abs(relativePos.y)) {\\r\\n    draw = 1.;\\r\\n  }\\r\\n\\r\\n  return draw;\\r\\n\\r\\n  // float draw = 1. - step(r, len);\\r\\n  // return draw;\\r\\n}\\r\\n\\r\\nfloat waveCurve(float A, float B, float x) {\\r\\n  return A * (sin(PI * (x / B + 1.) * (x / B + 1.)) * (1. - step(0., x)) + -sin(PI * (-x / B + 1.) * (-x / B + 1.)) * step(0., x));\\r\\n}\\r\\n\\r\\nfloat waveCurveGrad(float A, float B, float x) {\\r\\n  return A * (cos(PI * (x / B + 1.) * (x / B + 1.)) * 2. * PI / B * (x / B + 1.) * (1. - step(0., x)) +\\r\\n          -cos(PI * (-x / B + 1.) * (-x / B + 1.)) * 2. * PI / (-B) * (-x / B + 1.) * step(0., x));\\r\\n}\\r\\n\\r\\nfloat isAnimateWave() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  vec2 vec = endPos - startPos;\\r\\n  vec2 norm = normalize(vec2(-vec.y, vec.x));\\r\\n  // vec2 norm = normalize(n);\\r\\n  mat2 rotateMat = mat2(norm.y, norm.x, -norm.x, norm.y); // rotate to horizental\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  // float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n  // float r = v_animateMaxWidth * 2. + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 4.);\\r\\n  float r = v_animateMaxWidth + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 2.);\\r\\n  // float r = 0.5 * totalLen;\\r\\n\\r\\n  float currWidth = length(dot(pos - startPos, norm));\\r\\n\\r\\n  vec2 center = startPos + normalize(vec) * r;\\r\\n  vec2 newPos = center + (rotateMat * (pos - center));\\r\\n  vec2 relativePos = newPos - center;\\r\\n\\r\\n  float shapeLen = 2. * v_animateMaxWidth; // TODO: may be configurable\\r\\n  float draw = 1.;\\r\\n  if (length(relativePos.x) < shapeLen / 2. || currWidth > v_lineWidth) {\\r\\n    draw = 0.;\\r\\n  }\\r\\n  float A = v_animateMaxWidth - v_lineWidth;\\r\\n  float B = shapeLen / 2.;\\r\\n  if (length(relativePos.x) < shapeLen / 2. && abs(waveCurve(A, B, relativePos.x) - relativePos.y) < v_lineWidth * sqrt(1. + abs(pow(waveCurveGrad(A, B, relativePos.x), 1.)))) {\\r\\n    draw = 1.;\\r\\n  }\\r\\n\\r\\n  return draw;\\r\\n}\\r\\n\\r\\nfloat isAnimateDot() {\\r\\n  vec2 pos = gl_FragCoord.xy;\\r\\n  vec2 viewport = 2. * v_screen;\\r\\n  float maxLen = length(viewport);\\r\\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\\r\\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\\r\\n\\r\\n  float totalLen = distance(startPos, endPos);\\r\\n  float len = distance(pos, startPos);\\r\\n\\r\\n  vec2 vec = endPos - startPos;\\r\\n\\r\\n  const int maxDotNum = 15; // NOTE: currently support 15 as max, it must be fixed\\r\\n  float timeOffset = animateDotInterval;\\r\\n  float dotLen = v_lineWidth;\\r\\n  float currOffset = 0.;\\r\\n  float draw = 0.;\\r\\n  for (int i = 0; i < maxDotNum; i++) {\\r\\n      if (i < animateDotNum) {\\r\\n        float r = ease(fract((v_time - 0.2 * currOffset / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n        // float drawCurr = (1. - step(r, len)) * (step(r - 10., len));\\r\\n        vec2 center = startPos + normalize(vec) * r;\\r\\n        float drawCurr = step(length(pos - center), v_lineWidth);\\r\\n        draw = min(1., draw + drawCurr);\\r\\n        currOffset += timeOffset;\\r\\n      }\\r\\n  }\\r\\n  /*\\r\\n  float r1 =\\r\\n      ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n  float r2 =\\r\\n      ease(fract((v_time - 0.2 * 1. / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n  float r3 =\\r\\n      ease(fract((v_time - 0.2 * 2. / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\\r\\n  // float r = 0.5 * totalLen;\\r\\n  float draw1 = (1. - step(r1, len)) * (step(r1 - 10., len));\\r\\n  float draw2 = (1. - step(r2, len)) * (step(r2 - 10., len));\\r\\n  float draw3 = (1. - step(r3, len)) * (step(r3 - 10., len));\\r\\n  float draw = min(1., draw1 + draw2 + draw3);\\r\\n  */\\r\\n  return draw;\\r\\n}\"","export default \"void main(void) {\\r\\n  float part = abs(fract(length(v_lengthSoFar) * lineSize * 5.0));\\r\\n\\r\\n  // line types\\r\\n  if (type >= 2.5) { // 3.0 dotted\\r\\n    part = fract(part * 3.0);\\r\\n    if (part < 0.5)\\r\\n      discard;\\r\\n  } else if (type >= 1.5) { // 2.0 - chain dotted\\r\\n    if (part < 0.15)\\r\\n      discard;\\r\\n    if (part > 0.30 && part < 0.45)\\r\\n      discard;\\r\\n  } else if (type >= 0.5) { // 1.0 - dashed\\r\\n    if (part < 0.5)\\r\\n      discard;\\r\\n  }\\r\\n\\r\\n  // line animate types\\r\\n  if (animateType >= 5.5) {\\r\\n    gl_FragColor = isAnimateDot() * color;\\r\\n  } else if (animateType >= 4.5) {\\r\\n    gl_FragColor = isAnimateWave() * color;\\r\\n  } else if (animateType >= 3.5) {\\r\\n    gl_FragColor = isAnimateBubble() * color;\\r\\n  } else if (animateType >= 2.5) {\\r\\n    gl_FragColor = isAnimateCoveredDoubleGradient() * animateColor +\\r\\n                   (1. - isAnimateCoveredDoubleGradient()) * color;\\r\\n  } else if (animateType >= 1.5) {\\r\\n    gl_FragColor = isAnimateCoveredGradient() * animateColor +\\r\\n                   (1. - isAnimateCoveredGradient()) * color;\\r\\n  } else if (animateType >= 0.5) {\\r\\n    gl_FragColor =\\r\\n        isAnimateCovered() * animateColor + (1. - isAnimateCovered()) * color;\\r\\n  } else {\\r\\n    gl_FragColor = vec4(color.r, color.g, color.b, color.a - length(n));\\r\\n  }\\r\\n}\"","import vsLineHead from './vsLineHead.glsl';\r\nimport vsLineMain from './vsLineMain.glsl';\r\nimport getShiftFuncs from './getShiftFuncs.glsl';\r\n\r\nimport { easeFunctions } from '../easeFunctions';\r\nimport fsLineHead from './fsLineHead.glsl';\r\nimport fsLineAnimateFuncs from './fsLineAnimateFuncs.glsl';\r\nimport fsLineMain from './fsLineMain.glsl';\r\n\r\nconst vsLine = [vsLineHead, getShiftFuncs, vsLineMain].join('\\n');\r\nconst easeFunctionPart = ease => {\r\n  return `${easeFunctions[ease ? ease : 'linear']}`;\r\n};\r\n\r\nconst fsLineAnimate = ease => {\r\n  return [\r\n    fsLineHead,\r\n    easeFunctionPart(ease),\r\n    fsLineAnimateFuncs,\r\n    fsLineMain,\r\n  ].join('\\n');\r\n};\r\n\r\nconst elementShaders = {\r\n  vsLine,\r\n  fsLineAnimate,\r\n};\r\n\r\nexport { elementShaders };\r\n","export default \"attribute vec2 curveShift;\\r\\nvec4 getShiftCurve(void) {\\r\\n  vec2 shiftN = vec2(curveShift.x, aspect2 * curveShift.y);\\r\\n  float length = length(screen * shiftN);\\r\\n  return vec4(exc * (length == 0.0 ? vec2(0, 0) : shiftN * 0.5 / length), 0, 0);\\r\\n}\\r\\nattribute vec2 circleShift;\\r\\nvec4 getShiftCircle(void) { return vec4(size * circleShift, 0, 0); }\"","export default \"void main(void) {\\r\\n  vec2 finalWidth = vec2(max(width, animateMaxWidth), max(width, animateMaxWidth));\\r\\n  gl_Position = getShiftCurve() + getShiftCircle() +\\r\\n                vec4(finalWidth / screen * normal, 0, 0) + transform * vec4(position, 0, 1);\\r\\n\\r\\n  vec4 p = transform * vec4(lengthSoFar, 0, 0);\\r\\n  v_lengthSoFar = vec2(p.x, p.y / aspect);\\r\\n  v_time = time;\\r\\n\\r\\n  // v_startPos = startPos;\\r\\n  // v_endPos = endPos;\\r\\n  v_startPos = (transform * vec4(startPos, 0, 1)).xy;\\r\\n  v_endPos = (transform * vec4(endPos, 0, 1)).xy;\\r\\n  v_screen = screen;\\r\\n  v_lineWidth = width;\\r\\n  v_animateMaxWidth = animateMaxWidth;\\r\\n  v_size = size;\\r\\n\\r\\n  n = normal;\\r\\n}\\r\\n\"","// import ccNetViz_primitive from '../../primitive';\r\n// import ccNetViz_gl from '../../gl';\r\n// import ccNetViz_geomutils from '../../geomutils';\r\n// import { normalize } from '../util';\r\nimport { elementShaders } from '../shaders';\r\n// import { BaseShape } from './baseShape';\r\n\r\nconst BaseShape = ccNetViz.BaseShape;\r\nconst ccNetViz_primitive = ccNetViz.tools.primitive;\r\nconst ccNetViz_gl = ccNetViz.tools.gl;\r\nconst ccNetViz_geomutils = ccNetViz.tools.geomutils;\r\nconst normalize = ccNetViz.tools.normalize;\r\n\r\nconst stylesTransl = {\r\n  line: 0,\r\n  dashed: 1,\r\n  'chain-dotted': 2,\r\n  dotted: 3,\r\n};\r\nconst getEdgeType = t => {\r\n  if (t !== undefined) {\r\n    t = stylesTransl[t];\r\n  }\r\n\r\n  if (t === undefined || typeof t !== 'number') {\r\n    t = 0;\r\n  }\r\n\r\n  return t;\r\n};\r\n\r\nconst getEdgeStyleSize = c => {\r\n  return c.width / 120;\r\n  /*      let avsize = (c.width + c.height)/2;\r\n    let koef = (Math.min(Math.max((avsize - 150)/150, 0),1)+1)*1.3;\r\n    //koef 1 for 150 size and 1.4 for 300 size\r\n    return c.width/(130*koef);\r\n*/\r\n};\r\n\r\nconst animateStylesTransl = {\r\n  none: 0,\r\n  basic: 1,\r\n  gradient: 2,\r\n  'double-gradient': 3,\r\n  'shape-bubble': 4,\r\n  'shape-wave': 5,\r\n  'shape-dot': 6,\r\n};\r\n\r\nconst getEdgeAnimateType = t => {\r\n  if (t !== undefined) {\r\n    t = animateStylesTransl[t];\r\n  }\r\n\r\n  if (t === undefined || typeof t !== 'number') {\r\n    t = 0;\r\n  }\r\n\r\n  return t;\r\n};\r\n\r\nclass AnimateLine extends BaseShape {\r\n  constructor(gl, edgeStyle) {\r\n    super();\r\n\r\n    this.filler = shapeFillers.lines;\r\n\r\n    const hasAnimation =\r\n      !!edgeStyle.animateType && edgeStyle.animateType !== 'none';\r\n    // TODO: check has shape animation is not best way\r\n    const hasShapeAnimation =\r\n      hasAnimation && getEdgeAnimateType(edgeStyle.animateType) > 3.5;\r\n    this._primitive = new ccNetViz_primitive(\r\n      gl,\r\n      edgeStyle,\r\n      null,\r\n      elementShaders.vsLine,\r\n      elementShaders.fsLineAnimate(edgeStyle.animateEase),\r\n      c => {\r\n        let uniforms = c.shader.uniforms;\r\n        uniforms.exc && gl.uniform1f(uniforms.exc, c.curveExc);\r\n        gl.uniform2f(uniforms.screen, c.width, c.height);\r\n        let size = 2.5 * c.nodeSize;\r\n        uniforms.size &&\r\n          gl.uniform2f(uniforms.size, size / c.width, size / c.height);\r\n        gl.uniform1f(uniforms.lineSize, getEdgeStyleSize(c));\r\n        gl.uniform1f(uniforms.aspect2, c.aspect2);\r\n        gl.uniform1f(uniforms.aspect, c.aspect);\r\n        gl.uniform1f(uniforms.width, c.style.width);\r\n        gl.uniform1f(uniforms.type, getEdgeType(c.style.type));\r\n        ccNetViz_gl.uniformColor(gl, uniforms.color, c.style.color);\r\n\r\n        if (hasAnimation) {\r\n          gl.uniform1f(\r\n            uniforms.animateType,\r\n            getEdgeAnimateType(c.style.animateType)\r\n          );\r\n          gl.uniform1f(uniforms.animateSpeed, c.style.animateSpeed);\r\n          ccNetViz_gl.uniformColor(\r\n            gl,\r\n            uniforms.animateColor,\r\n            c.style.animateColor\r\n          );\r\n\r\n          hasShapeAnimation &&\r\n            gl.uniform1f(uniforms.animateMaxWidth, c.style.animateMaxWidth);\r\n          c.style.animateType === 'shape-dot' &&\r\n            gl.uniform1i(uniforms.animateDotNum, c.style.animateDotNum);\r\n          gl.uniform1f(uniforms.animateDotInterval, c.style.animateDotInterval);\r\n        }\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\nconst setVerticeCurveShift = (v, iV, s, t) => {\r\n  let ct1 = {},\r\n    ct2 = {};\r\n  let csx, csy, ctx, cty, cisx, cisy, sisy, citx, city;\r\n  ccNetViz_geomutils.getCurveShift(t.e, ct1);\r\n  ctx = ct1.x;\r\n  cty = ct1.y;\r\n  citx = ct1.cx;\r\n  city = ct1.cy;\r\n\r\n  ccNetViz_geomutils.getCurveShift(s.e, ct2);\r\n  csx = ct2.x;\r\n  csy = ct2.y;\r\n  cisx = ct2.cx;\r\n  cisy = ct2.cy;\r\n\r\n  v.curveShift &&\r\n    ccNetViz_primitive.vertices(\r\n      v.curveShift,\r\n      iV,\r\n      -csy,\r\n      csx,\r\n      -csy,\r\n      csx,\r\n      -cty,\r\n      ctx,\r\n      -cty,\r\n      ctx\r\n    );\r\n  v.circleShift &&\r\n    ccNetViz_primitive.vertices(\r\n      v.circleShift,\r\n      iV,\r\n      -cisy,\r\n      cisx,\r\n      -cisy,\r\n      cisx,\r\n      -city,\r\n      citx,\r\n      -city,\r\n      citx\r\n    );\r\n};\r\n\r\nconst shapeFillers = {\r\n  lines: style => ({\r\n    set: (v, e, iV, iI) => {\r\n      let s = ccNetViz_geomutils.edgeSource(e);\r\n      let t = ccNetViz_geomutils.edgeTarget(e);\r\n      let dx = s.x - t.x;\r\n      let dy = s.y - t.y;\r\n      let d = normalize(s, t);\r\n\r\n      setVerticeCurveShift(v, iV, s, t);\r\n\r\n      ccNetViz_primitive.vertices(\r\n        v.position,\r\n        iV,\r\n        s.x,\r\n        s.y,\r\n        s.x,\r\n        s.y,\r\n        t.x,\r\n        t.y,\r\n        t.x,\r\n        t.y\r\n      );\r\n      ccNetViz_primitive.vertices(\r\n        v.lengthSoFar,\r\n        iV,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        dx,\r\n        dy,\r\n        dx,\r\n        dy\r\n      );\r\n      ccNetViz_primitive.vertices(\r\n        v.normal,\r\n        iV,\r\n        -d.y,\r\n        d.x,\r\n        d.y,\r\n        -d.x,\r\n        d.y,\r\n        -d.x,\r\n        -d.y,\r\n        d.x\r\n      );\r\n\r\n      // NOTE: edge animation set from style\r\n      const hasEdgeAnimation =\r\n        !!style.animateType && style.animateType !== 'none';\r\n      if (hasEdgeAnimation) {\r\n        // when do edge animation, shader need to know the startPos and endPos\r\n        ccNetViz_primitive.vertices(\r\n          v.startPos,\r\n          iV,\r\n          s.x,\r\n          s.y,\r\n          s.x,\r\n          s.y,\r\n          s.x,\r\n          s.y,\r\n          s.x,\r\n          s.y\r\n        );\r\n        ccNetViz_primitive.vertices(\r\n          v.endPos,\r\n          iV,\r\n          t.x,\r\n          t.y,\r\n          t.x,\r\n          t.y,\r\n          t.x,\r\n          t.y,\r\n          t.x,\r\n          t.y\r\n        );\r\n      }\r\n\r\n      ccNetViz_primitive.quad(v.indices, iV, iI);\r\n    },\r\n  }),\r\n};\r\n\r\nexport { AnimateLine };\r\n","// import BasePlugin from './basePlugin';\r\nimport { AnimateLine } from './shapes/animateLine';\r\n\r\n// TODO: check ccNetViz\r\nif (!ccNetViz) {\r\n  console.error('Please import ccNetViz library');\r\n}\r\n\r\nconst BasePlugin = ccNetViz.BasePlugin;\r\n\r\nclass AnimateEdgePlugin extends BasePlugin {\r\n  constructor(options) {\r\n    super(options);\r\n\r\n    const { gl, edgeStyle } = options;\r\n\r\n    this.scene.add('lines', new AnimateLine(gl, edgeStyle));\r\n  }\r\n  runRegistrations({ gl, textures }) {\r\n    let defaultAdder = (section, addSection) => {\r\n      if (typeof section.style.texture === 'string')\r\n        section.style.texture = textures.get(\r\n          gl,\r\n          section.style.texture,\r\n          addSection\r\n        );\r\n      else addSection();\r\n    };\r\n\r\n    this.register('lines', 'lines', defaultAdder);\r\n  }\r\n}\r\n\r\nccNetViz.Shaders.edge = AnimateEdgePlugin"],"sourceRoot":""}