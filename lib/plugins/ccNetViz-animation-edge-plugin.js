!function(t,n){if("object"==typeof exports&&"object"==typeof module)module.exports=n();else if("function"==typeof define&&define.amd)define([],n);else{var r=n();for(var e in r)("object"==typeof exports?exports:t)[e]=r[e]}}(window,function(){return function(t){var n={};function r(e){if(n[e])return n[e].exports;var a=n[e]={i:e,l:!1,exports:{}};return t[e].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=t,r.c=n,r.d=function(t,n,e){r.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:e})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,n){if(1&n&&(t=r(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(r.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var a in t)r.d(e,a,function(n){return t[n]}.bind(null,a));return e},r.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(n,"a",n),n},r.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},r.p="",r(r.s=0)}([function(t,n,r){"use strict";r.r(n);const e={linear:"float ease(float t) {\r\n  return t;\r\n}\r\n","sin-in":"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat ease(float t) {\r\n  return sin((t - 1.0) * HALF_PI) + 1.0;\r\n}\r\n","sin-out":"#ifndef HALF_PI\r\n#define HALF_PI 1.5707963267948966\r\n#endif\r\n\r\nfloat ease(float t) {\r\n  return sin(t * HALF_PI);\r\n}","sin-inout":"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat ease(float t) {\r\n  return -0.5 * (cos(PI * t) - 1.0);\r\n}","sin-inout-inv":"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat ease(float t) {\r\n  return acos(1. - 2. * t) / PI;\r\n}","exp-in":"float ease(float t) {\r\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\r\n}","exp-out":"float ease(float t) {\r\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\r\n}\r\n","exp-inout":"float ease(float t) {\r\n  return t == 0.0 || t == 1.0\r\n    ? t\r\n    : t < 0.5\r\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\r\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\r\n}","bounce-in":"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat bounceOut(float t) {\r\n  const float a = 4.0 / 11.0;\r\n  const float b = 8.0 / 11.0;\r\n  const float c = 9.0 / 10.0;\r\n\r\n  const float ca = 4356.0 / 361.0;\r\n  const float cb = 35442.0 / 1805.0;\r\n  const float cc = 16061.0 / 1805.0;\r\n\r\n  float t2 = t * t;\r\n\r\n  return t < a\r\n    ? 7.5625 * t2\r\n    : t < b\r\n      ? 9.075 * t2 - 9.9 * t + 3.4\r\n      : t < c\r\n        ? ca * t2 - cb * t + cc\r\n        : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n\r\n\r\nfloat ease(float t) {\r\n  return 1.0 - bounceOut(1.0 - t);\r\n}","bounce-out":"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat ease(float t) {\r\n  const float a = 4.0 / 11.0;\r\n  const float b = 8.0 / 11.0;\r\n  const float c = 9.0 / 10.0;\r\n\r\n  const float ca = 4356.0 / 361.0;\r\n  const float cb = 35442.0 / 1805.0;\r\n  const float cc = 16061.0 / 1805.0;\r\n\r\n  float t2 = t * t;\r\n\r\n  return t < a\r\n    ? 7.5625 * t2\r\n    : t < b\r\n      ? 9.075 * t2 - 9.9 * t + 3.4\r\n      : t < c\r\n        ? ca * t2 - cb * t + cc\r\n        : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n","bounce-inout":"#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat bounceOut(float t) {\r\n  const float a = 4.0 / 11.0;\r\n  const float b = 8.0 / 11.0;\r\n  const float c = 9.0 / 10.0;\r\n\r\n  const float ca = 4356.0 / 361.0;\r\n  const float cb = 35442.0 / 1805.0;\r\n  const float cc = 16061.0 / 1805.0;\r\n\r\n  float t2 = t * t;\r\n\r\n  return t < a\r\n    ? 7.5625 * t2\r\n    : t < b\r\n      ? 9.075 * t2 - 9.9 * t + 3.4\r\n      : t < c\r\n        ? ca * t2 - cb * t + cc\r\n        : 10.8 * t * t - 20.52 * t + 10.72;\r\n}\r\n\r\nfloat ease(float t) {\r\n  return t < 0.5\r\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\r\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\r\n}","circular-in":"float ease(float t) {\r\n  return 1.0 - sqrt(1.0 - t * t);\r\n}","circular-out":"float ease(float t) {\r\n  return sqrt((2.0 - t) * t);\r\n}","circular-inout":"float ease(float t) {\r\n  return t < 0.5\r\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\r\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\r\n}","quad-in":"float ease(float t) {\r\n  return t * t;\r\n}","quad-out":"float ease(float t) {\r\n  return -t * (t - 2.0);\r\n}","quad-inout":"float ease(float t) {\r\n  return t < 0.5\r\n    ? +8.0 * pow(t, 4.0)\r\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\r\n}","cubic-in":"float ease(float t) {\r\n  return t * t * t;\r\n}","cubic-out":"float ease(float t) {\r\n  float f = t - 1.0;\r\n  return f * f * f + 1.0;\r\n}","cubic-inout":"float ease(float t) {\r\n  return t < 0.5\r\n    ? 4.0 * t * t * t\r\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\r\n}","quart-in":"float ease(float t) {\r\n  return pow(t, 4.0);\r\n}","quart-out":"float ease(float t) {\r\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\r\n}","quart-inout":"float ease(float t) {\r\n  return t < 0.5\r\n    ? +8.0 * pow(t, 4.0)\r\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\r\n}","quart-inout-inv":"float ease(float t) {\r\n  return t < 0.5\r\n    ? pow((t / 8.), 0.25)\r\n    : -pow((1.0 - t) / 8., 0.25) + 1.;\r\n}","quint-in":"float ease(float t) {\r\n  return pow(t, 5.0);\r\n}","quint-out":"float ease(float t) {\r\n  return 1.0 + (pow(t - 1.0, 5.0)); // NOTE: fix original bug '-' -> '+'\r\n}","quint-inout":"float ease(float t) {\r\n  return t < 0.5\r\n    ? +16.0 * pow(t, 5.0)\r\n    : 0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0; // NOTE: fix original bug, no '-'\r\n}\r\n"};var a="precision mediump float;\r\nuniform float type;\r\nuniform float animateType;\r\nuniform vec4 color;\r\nuniform vec4 animateColor;\r\nuniform float animateSpeed;\r\nuniform int animateDotNum;\r\nuniform float animateDotInterval;\r\nvarying vec2 n;\r\nvarying float v_time;\r\nvarying vec2 v_startPos;\r\nvarying vec2 v_endPos;\r\nvarying vec2 v_screen;\r\nvarying vec2 v_lengthSoFar;\r\nvarying float v_lineWidth;\r\nvarying float v_animateMaxWidth;\r\nvarying vec2 v_size;\r\n\r\nuniform float lineSize;\r\n",o="#ifndef PI\r\n#define PI 3.141592653589793\r\n#endif\r\n\r\nfloat isAnimateCovered() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  float len = distance(pos, startPos);\r\n  // float r = 300.;\r\n  float r =\r\n      ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n  // float r = 0.5 * totalLen;\r\n  float draw = 1. - step(r, len);\r\n  return draw;\r\n}\r\n\r\nfloat isAnimateCoveredGradient() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  float len = distance(pos, startPos);\r\n  float gradLen = 180.; // TODO: can config\r\n  float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) *\r\n            (totalLen + gradLen / 2.); // NOTE: use 0.2 as a proper factor\r\n  // float r = 0.5 * totalLen;\r\n  float draw = fract(smoothstep(r - gradLen, r, len));\r\n  return draw;\r\n}\r\n\r\nfloat isAnimateCoveredDoubleGradient() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  float len = distance(pos, startPos);\r\n  float gradLen = 90.; // TODO: can config\r\n  float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) *\r\n            (totalLen + gradLen / 2.); // NOTE: use 0.2 as a proper factor\r\n\r\n  float draw = (1. - step(r, len)) * fract(smoothstep(r - gradLen, r, len)) +\r\n               (1. - step(r + gradLen, len)) * step(r, len) *\r\n                   (1. - fract(smoothstep(r, r + gradLen, len)));\r\n  return draw;\r\n}\r\n\r\nfloat isAnimateBubble() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  vec2 vec = endPos - startPos;\r\n  vec2 norm = normalize(vec2(-vec.y, vec.x));\r\n  // vec2 norm = normalize(n);\r\n  mat2 rotateMat = mat2(norm.y, norm.x, -norm.x, norm.y); // rotate to horizental\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  float r = v_animateMaxWidth * 2. + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 4.);\r\n  // float r = 0.5 * totalLen;\r\n\r\n  float currWidth = length(dot(pos - startPos, norm));\r\n\r\n  vec2 center = startPos + normalize(vec) * r;\r\n  vec2 newPos = center + (rotateMat * (pos - center));\r\n  vec2 relativePos = newPos - center;\r\n\r\n  // if (currWidth > v_lineWidth && length(pos - center) > v_animateMaxWidth) {\r\n    // return 0.;\r\n  // }\r\n\r\n  float shapeLen = 4. * v_animateMaxWidth; // TODO: may be configurable\r\n  float A = (v_animateMaxWidth - v_lineWidth) / 2.;\r\n  float K = 2. * PI / shapeLen;\r\n  float B = v_lineWidth + (v_animateMaxWidth - v_lineWidth) / 2.;\r\n  float draw = 1.;\r\n  if (currWidth > v_lineWidth) {\r\n    draw = 0.;\r\n  }\r\n  if (length(relativePos.x) < shapeLen / 2. && abs(A * cos(K * relativePos.x) + B) > abs(relativePos.y)) {\r\n    draw = 1.;\r\n  }\r\n\r\n  return draw;\r\n\r\n  // float draw = 1. - step(r, len);\r\n  // return draw;\r\n}\r\n\r\nfloat waveCurve(float A, float B, float x) {\r\n  return A * (sin(PI * (x / B + 1.) * (x / B + 1.)) * (1. - step(0., x)) + -sin(PI * (-x / B + 1.) * (-x / B + 1.)) * step(0., x));\r\n}\r\n\r\nfloat waveCurveGrad(float A, float B, float x) {\r\n  return A * (cos(PI * (x / B + 1.) * (x / B + 1.)) * 2. * PI / B * (x / B + 1.) * (1. - step(0., x)) +\r\n          -cos(PI * (-x / B + 1.) * (-x / B + 1.)) * 2. * PI / (-B) * (-x / B + 1.) * step(0., x));\r\n}\r\n\r\nfloat isAnimateWave() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  vec2 vec = endPos - startPos;\r\n  vec2 norm = normalize(vec2(-vec.y, vec.x));\r\n  // vec2 norm = normalize(n);\r\n  mat2 rotateMat = mat2(norm.y, norm.x, -norm.x, norm.y); // rotate to horizental\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  // float r = ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n  // float r = v_animateMaxWidth * 2. + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 4.);\r\n  float r = v_animateMaxWidth + ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * (totalLen - v_animateMaxWidth * 2.);\r\n  // float r = 0.5 * totalLen;\r\n\r\n  float currWidth = length(dot(pos - startPos, norm));\r\n\r\n  vec2 center = startPos + normalize(vec) * r;\r\n  vec2 newPos = center + (rotateMat * (pos - center));\r\n  vec2 relativePos = newPos - center;\r\n\r\n  float shapeLen = 2. * v_animateMaxWidth; // TODO: may be configurable\r\n  float draw = 1.;\r\n  if (length(relativePos.x) < shapeLen / 2. || currWidth > v_lineWidth) {\r\n    draw = 0.;\r\n  }\r\n  float A = v_animateMaxWidth - v_lineWidth;\r\n  float B = shapeLen / 2.;\r\n  if (length(relativePos.x) < shapeLen / 2. && abs(waveCurve(A, B, relativePos.x) - relativePos.y) < v_lineWidth * sqrt(1. + abs(pow(waveCurveGrad(A, B, relativePos.x), 1.)))) {\r\n    draw = 1.;\r\n  }\r\n\r\n  return draw;\r\n}\r\n\r\nfloat isAnimateDot() {\r\n  vec2 pos = gl_FragCoord.xy;\r\n  vec2 viewport = 2. * v_screen;\r\n  float maxLen = length(viewport);\r\n  vec2 startPos = viewport * (v_startPos + vec2(1., 1.)) / 2.;\r\n  vec2 endPos = viewport * (v_endPos + vec2(1., 1.)) / 2.;\r\n\r\n  float totalLen = distance(startPos, endPos);\r\n  float len = distance(pos, startPos);\r\n\r\n  vec2 vec = endPos - startPos;\r\n\r\n  const int maxDotNum = 15; // NOTE: currently support 15 as max, it must be fixed\r\n  float timeOffset = animateDotInterval;\r\n  float dotLen = v_lineWidth;\r\n  float currOffset = 0.;\r\n  float draw = 0.;\r\n  for (int i = 0; i < maxDotNum; i++) {\r\n      if (i < animateDotNum) {\r\n        float r = ease(fract((v_time - 0.2 * currOffset / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n        // float drawCurr = (1. - step(r, len)) * (step(r - 10., len));\r\n        vec2 center = startPos + normalize(vec) * r;\r\n        float drawCurr = step(length(pos - center), v_lineWidth);\r\n        draw = min(1., draw + drawCurr);\r\n        currOffset += timeOffset;\r\n      }\r\n  }\r\n  /*\r\n  float r1 =\r\n      ease(fract(v_time * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n  float r2 =\r\n      ease(fract((v_time - 0.2 * 1. / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n  float r3 =\r\n      ease(fract((v_time - 0.2 * 2. / animateSpeed) * animateSpeed * 0.2 * maxLen / totalLen)) * totalLen;\r\n  // float r = 0.5 * totalLen;\r\n  float draw1 = (1. - step(r1, len)) * (step(r1 - 10., len));\r\n  float draw2 = (1. - step(r2, len)) * (step(r2 - 10., len));\r\n  float draw3 = (1. - step(r3, len)) * (step(r3 - 10., len));\r\n  float draw = min(1., draw1 + draw2 + draw3);\r\n  */\r\n  return draw;\r\n}",i="void main(void) {\r\n  float part = abs(fract(length(v_lengthSoFar) * lineSize * 5.0));\r\n\r\n  // line types\r\n  if (type >= 2.5) { // 3.0 dotted\r\n    part = fract(part * 3.0);\r\n    if (part < 0.5)\r\n      discard;\r\n  } else if (type >= 1.5) { // 2.0 - chain dotted\r\n    if (part < 0.15)\r\n      discard;\r\n    if (part > 0.30 && part < 0.45)\r\n      discard;\r\n  } else if (type >= 0.5) { // 1.0 - dashed\r\n    if (part < 0.5)\r\n      discard;\r\n  }\r\n\r\n  // line animate types\r\n  if (animateType >= 5.5) {\r\n    gl_FragColor = isAnimateDot() * color;\r\n  } else if (animateType >= 4.5) {\r\n    gl_FragColor = isAnimateWave() * color;\r\n  } else if (animateType >= 3.5) {\r\n    gl_FragColor = isAnimateBubble() * color;\r\n  } else if (animateType >= 2.5) {\r\n    gl_FragColor = isAnimateCoveredDoubleGradient() * animateColor +\r\n                   (1. - isAnimateCoveredDoubleGradient()) * color;\r\n  } else if (animateType >= 1.5) {\r\n    gl_FragColor = isAnimateCoveredGradient() * animateColor +\r\n                   (1. - isAnimateCoveredGradient()) * color;\r\n  } else if (animateType >= 0.5) {\r\n    gl_FragColor =\r\n        isAnimateCovered() * animateColor + (1. - isAnimateCovered()) * color;\r\n  } else {\r\n    gl_FragColor = vec4(color.r, color.g, color.b, color.a - length(n));\r\n  }\r\n}";const l=["precision mediump float;\r\nattribute vec2 position;\r\nattribute vec2 normal;\r\nattribute vec2 lengthSoFar;\r\nattribute vec2 startPos;\r\nattribute vec2 endPos;\r\nuniform float time;\r\nuniform float exc;\r\nuniform vec2 size;\r\nuniform vec2 screen;\r\nuniform float aspect2;\r\nuniform float aspect;\r\nuniform float width;\r\nuniform float animateMaxWidth;\r\nuniform mat4 transform;\r\nvarying float v_time;\r\nvarying vec2 v_startPos;\r\nvarying vec2 v_endPos;\r\nvarying vec2 v_screen;\r\nvarying vec2 n;\r\nvarying vec2 v_lengthSoFar;\r\nvarying float v_lineWidth;\r\nvarying float v_animateMaxWidth;\r\nvarying vec2 v_size;\r\n","attribute vec2 curveShift;\r\nvec4 getShiftCurve(void) {\r\n  vec2 shiftN = vec2(curveShift.x, aspect2 * curveShift.y);\r\n  float length = length(screen * shiftN);\r\n  return vec4(exc * (length == 0.0 ? vec2(0, 0) : shiftN * 0.5 / length), 0, 0);\r\n}\r\nattribute vec2 circleShift;\r\nvec4 getShiftCircle(void) { return vec4(size * circleShift, 0, 0); }","void main(void) {\r\n  vec2 finalWidth = vec2(max(width, animateMaxWidth), max(width, animateMaxWidth));\r\n  gl_Position = getShiftCurve() + getShiftCircle() +\r\n                vec4(finalWidth / screen * normal, 0, 0) + transform * vec4(position, 0, 1);\r\n\r\n  vec4 p = transform * vec4(lengthSoFar, 0, 0);\r\n  v_lengthSoFar = vec2(p.x, p.y / aspect);\r\n  v_time = time;\r\n\r\n  // v_startPos = startPos;\r\n  // v_endPos = endPos;\r\n  v_startPos = (transform * vec4(startPos, 0, 1)).xy;\r\n  v_endPos = (transform * vec4(endPos, 0, 1)).xy;\r\n  v_screen = screen;\r\n  v_lineWidth = width;\r\n  v_animateMaxWidth = animateMaxWidth;\r\n  v_size = size;\r\n\r\n  n = normal;\r\n}\r\n"].join("\n"),s=t=>`${e[t||"linear"]}`,f={vsLine:l,fsLineAnimate:t=>[a,s(t),o,i].join("\n")},c=ccNetViz.BaseShape,v=ccNetViz.tools.primitive,d=ccNetViz.tools.gl,u=ccNetViz.tools.geomutils,m=ccNetViz.tools.normalize,p={line:0,dashed:1,"chain-dotted":2,dotted:3},x=t=>(void 0!==t&&(t=p[t]),void 0!==t&&"number"==typeof t||(t=0),t),h=t=>t.width/120,g={none:0,basic:1,gradient:2,"double-gradient":3,"shape-bubble":4,"shape-wave":5,"shape-dot":6},y=t=>(void 0!==t&&(t=g[t]),void 0!==t&&"number"==typeof t||(t=0),t);class P extends c{constructor(t,n){super(),this.filler=_.lines;const r=!!n.animateType&&"none"!==n.animateType,e=r&&y(n.animateType)>3.5;this._primitive=new v(t,n,null,f.vsLine,f.fsLineAnimate(n.animateEase),n=>{let a=n.shader.uniforms;a.exc&&t.uniform1f(a.exc,n.curveExc),t.uniform2f(a.screen,n.width,n.height);let o=2.5*n.nodeSize;a.size&&t.uniform2f(a.size,o/n.width,o/n.height),t.uniform1f(a.lineSize,h(n)),t.uniform1f(a.aspect2,n.aspect2),t.uniform1f(a.aspect,n.aspect),t.uniform1f(a.width,n.style.width),t.uniform1f(a.type,x(n.style.type)),d.uniformColor(t,a.color,n.style.color),r&&(t.uniform1f(a.animateType,y(n.style.animateType)),t.uniform1f(a.animateSpeed,n.style.animateSpeed),d.uniformColor(t,a.animateColor,n.style.animateColor),e&&t.uniform1f(a.animateMaxWidth,n.style.animateMaxWidth),"shape-dot"===n.style.animateType&&t.uniform1i(a.animateDotNum,n.style.animateDotNum),t.uniform1f(a.animateDotInterval,n.style.animateDotInterval))})}}const _={lines:t=>({set:(n,r,e,a)=>{let o=u.edgeSource(r),i=u.edgeTarget(r),l=o.x-i.x,s=o.y-i.y,f=m(o,i);((t,n,r,e)=>{let a,o,i,l,s,f,c,d,m={},p={};u.getCurveShift(e.e,m),i=m.x,l=m.y,c=m.cx,d=m.cy,u.getCurveShift(r.e,p),a=p.x,o=p.y,s=p.cx,f=p.cy,t.curveShift&&v.vertices(t.curveShift,n,-o,a,-o,a,-l,i,-l,i),t.circleShift&&v.vertices(t.circleShift,n,-f,s,-f,s,-d,c,-d,c)})(n,e,o,i),v.vertices(n.position,e,o.x,o.y,o.x,o.y,i.x,i.y,i.x,i.y),v.vertices(n.lengthSoFar,e,0,0,0,0,l,s,l,s),v.vertices(n.normal,e,-f.y,f.x,f.y,-f.x,f.y,-f.x,-f.y,f.x),!!t.animateType&&"none"!==t.animateType&&(v.vertices(n.startPos,e,o.x,o.y,o.x,o.y,o.x,o.y,o.x,o.y),v.vertices(n.endPos,e,i.x,i.y,i.x,i.y,i.x,i.y,i.x,i.y)),v.quad(n.indices,e,a)}})};ccNetViz||console.error("Please import ccNetViz library");const w=ccNetViz.BasePlugin;ccNetViz.Shaders.edge=class extends w{constructor(t){super(t);const{gl:n,edgeStyle:r}=t;this.scene.add("lines",new P(n,r))}runRegistrations({gl:t,textures:n}){this.register("lines","lines",(r,e)=>{"string"==typeof r.style.texture?r.style.texture=n.get(t,r.style.texture,e):e()})}}}])});